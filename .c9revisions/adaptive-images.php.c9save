{"ts":1373035465241,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/* PROJECT INFO --------------------------------------------------------------------------------------------------------\n   Version:   1.5.2\n   Changelog: http://adaptive-images.com/changelog.txt\n\n   Homepage:  http://adaptive-images.com\n   GitHub:    https://github.com/MattWilcox/Adaptive-Images\n   Twitter:   @responsiveimg\n\n   LEGAL:\n   Adaptive Images by Matt Wilcox is licensed under a Creative Commons Attribution 3.0 Unported License.\n\n/* CONFIG ----------------------------------------------------------------------------------------------------------- */\n\n$resolutions   = array(1382, 992, 768, 480); // the resolution break-points to use (screen widths, in pixels)\n$cache_path    = \"ai-cache\"; // where to store the generated re-sized images. Specify from your document root!\n$jpg_quality   = 75; // the quality of any generated JPGs on a scale of 0 to 100\n$sharpen       = TRUE; // Shrinking images can blur details, perform a sharpen on re-scaled images?\n$watch_cache   = TRUE; // check that the adapted image isn't stale (ensures updated source images are re-cached)\n$browser_cache = 60*60*24*7; // How long the BROWSER cache should last (seconds, minutes, hours, days. 7days by default)\n\n/* END CONFIG ----------------------------------------------------------------------------------------------------------\n------------------------ Don't edit anything after this line unless you know what you're doing -------------------------\n--------------------------------------------------------------------------------------------------------------------- */\n\n/* get all of the required data from the HTTP request */\n$document_root  = $_SERVER['DOCUMENT_ROOT'];\n$requested_uri  = parse_url(urldecode($_SERVER['REQUEST_URI']), PHP_URL_PATH);\n$requested_file = basename($requested_uri);\n$source_file    = $document_root.$requested_uri;\n$resolution     = FALSE;\n\n/* Mobile detection \n   NOTE: only used in the event a cookie isn't available. */\nfunction is_mobile() {\n  $userAgent = strtolower($_SERVER['HTTP_USER_AGENT']);\n  return strpos($userAgent, 'mobile');\n}\n\n/* Does the UA string indicate this is a mobile? */\nif(!is_mobile()){\n  $is_mobile = FALSE;\n} else {\n  $is_mobile = TRUE;\n}\n\n// does the $cache_path directory exist already?\nif (!is_dir(\"$document_root/$cache_path\")) { // no\n  if (!mkdir(\"$document_root/$cache_path\", 0755, true)) { // so make it\n    if (!is_dir(\"$document_root/$cache_path\")) { // check again to protect against race conditions\n      // uh-oh, failed to make that directory\n      sendErrorImage(\"Failed to create cache directory at: $document_root/$cache_path\");\n    }\n  }\n}\n\n/* helper function: Send headers and returns an image. */\nfunction sendImage($filename, $browser_cache) {\n  $extension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n  if (in_array($extension, array('png', 'gif', 'jpeg'))) {\n    header(\"Content-Type: image/\".$extension);\n  } else {\n    header(\"Content-Type: image/jpeg\");\n  }\n  header(\"Cache-Control: private, max-age=\".$browser_cache);\n  header('Expires: '.gmdate('D, d M Y H:i:s', time()+$browser_cache).' GMT');\n  header('Content-Length: '.filesize($filename));\n  readfile($filename);\n  exit();\n}\n\n/* helper function: Create and send an image with an error message. */\nfunction sendErrorImage($message) {\n  /* get all of the required data from the HTTP request */\n  $document_root  = $_SERVER['DOCUMENT_ROOT'];\n  $requested_uri  = parse_url(urldecode($_SERVER['REQUEST_URI']), PHP_URL_PATH);\n  $requested_file = basename($requested_uri);\n  $source_file    = $document_root.$requested_uri;\n\n  if(!is_mobile()){\n    $is_mobile = \"FALSE\";\n  } else {\n    $is_mobile = \"TRUE\";\n  }\n\n  $im            = ImageCreateTrueColor(800, 300);\n  $text_color    = ImageColorAllocate($im, 233, 14, 91);\n  $message_color = ImageColorAllocate($im, 91, 112, 233);\n\n  ImageString($im, 5, 5, 5, \"Adaptive Images encountered a problem:\", $text_color);\n  ImageString($im, 3, 5, 25, $message, $message_color);\n\n  ImageString($im, 5, 5, 85, \"Potentially useful information:\", $text_color);\n  ImageString($im, 3, 5, 105, \"DOCUMENT ROOT IS: $document_root\", $text_color);\n  ImageString($im, 3, 5, 125, \"REQUESTED URI WAS: $requested_uri\", $text_color);\n  ImageString($im, 3, 5, 145, \"REQUESTED FILE WAS: $requested_file\", $text_color);\n  ImageString($im, 3, 5, 165, \"SOURCE FILE IS: $source_file\", $text_color);\n  ImageString($im, 3, 5, 185, \"DEVICE IS MOBILE? $is_mobile\", $text_color);\n\n  header(\"Cache-Control: no-store\");\n  header('Expires: '.gmdate('D, d M Y H:i:s', time()-1000).' GMT');\n  header('Content-Type: image/jpeg');\n  ImageJpeg($im);\n  ImageDestroy($im);\n  exit();\n}\n\n/* sharpen images function */\nfunction findSharp($intOrig, $intFinal) {\n  $intFinal = $intFinal * (750.0 / $intOrig);\n  $intA     = 52;\n  $intB     = -0.27810650887573124;\n  $intC     = .00047337278106508946;\n  $intRes   = $intA + $intB * $intFinal + $intC * $intFinal * $intFinal;\n  return max(round($intRes), 0);\n}\n\n/* refreshes the cached image if it's outdated */\nfunction refreshCache($source_file, $cache_file, $resolution) {\n  if (file_exists($cache_file)) {\n    // not modified\n    if (filemtime($cache_file) >= filemtime($source_file)) {\n      return $cache_file;\n    }\n\n    // modified, clear it\n    unlink($cache_file);\n  }\n  return generateImage($source_file, $cache_file, $resolution);\n}\n\n/* generates the given cache file for the given source file with the given resolution */\nfunction generateImage($source_file, $cache_file, $resolution) {\n  global $sharpen, $jpg_quality;\n\n  $extension = strtolower(pathinfo($source_file, PATHINFO_EXTENSION));\n\n  // Check the image dimensions\n  $dimensions   = GetImageSize($source_file);\n  $width        = $dimensions[0];\n  $height       = $dimensions[1];\n\n  // Do we need to downscale the image?\n  if ($width <= $resolution) { // no, because the width of the source image is already less than the client width\n    return $source_file;\n  }\n\n  // We need to resize the source image to the width of the resolution breakpoint we're working with\n  $ratio      = $height/$width;\n  $new_width  = $resolution;\n  $new_height = ceil($new_width * $ratio);\n  $dst        = ImageCreateTrueColor($new_width, $new_height); // re-sized image\n\n  switch ($extension) {\n    case 'png':\n      $src = @ImageCreateFromPng($source_file); // original image\n    break;\n    case 'gif':\n      $src = @ImageCreateFromGif($source_file); // original image\n    break;\n    default:\n      $src = @ImageCreateFromJpeg($source_file); // original image\n      ImageInterlace($dst, true); // Enable interlancing (progressive JPG, smaller size file)\n    break;\n  }\n\n  if($extension=='png'){\n    imagealphablending($dst, false);\n    imagesavealpha($dst,true);\n    $transparent = imagecolorallocatealpha($dst, 255, 255, 255, 127);\n    imagefilledrectangle($dst, 0, 0, $new_width, $new_height, $transparent);\n  }\n  \n  ImageCopyResampled($dst, $src, 0, 0, 0, 0, $new_width, $new_height, $width, $height); // do the resize in memory\n  ImageDestroy($src);\n\n  // sharpen the image?\n  // NOTE: requires PHP compiled with the bundled version of GD (see http://php.net/manual/en/function.imageconvolution.php)\n  if($sharpen == TRUE && function_exists('imageconvolution')) {\n    $intSharpness = findSharp($width, $new_width);\n    $arrMatrix = array(\n      array(-1, -2, -1),\n      array(-2, $intSharpness + 12, -2),\n      array(-1, -2, -1)\n    );\n    imageconvolution($dst, $arrMatrix, $intSharpness, 0);\n  }\n\n  $cache_dir = dirname($cache_file);\n\n  // does the directory exist already?\n  if (!is_dir($cache_dir)) { \n    if (!mkdir($cache_dir, 0755, true)) {\n      // check again if it really doesn't exist to protect against race conditions\n      if (!is_dir($cache_dir)) {\n        // uh-oh, failed to make that directory\n        ImageDestroy($dst);\n        sendErrorImage(\"Failed to create cache directory: $cache_dir\");\n      }\n    }\n  }\n\n  if (!is_writable($cache_dir)) {\n    sendErrorImage(\"The cache directory is not writable: $cache_dir\");\n  }\n\n  // save the new file in the appropriate path, and send a version to the browser\n  switch ($extension) {\n    case 'png':\n      $gotSaved = ImagePng($dst, $cache_file);\n    break;\n    case 'gif':\n      $gotSaved = ImageGif($dst, $cache_file);\n    break;\n    default:\n      $gotSaved = ImageJpeg($dst, $cache_file, $jpg_quality);\n    break;\n  }\n  ImageDestroy($dst);\n\n  if (!$gotSaved && !file_exists($cache_file)) {\n    sendErrorImage(\"Failed to create image: $cache_file\");\n  }\n\n  return $cache_file;\n}\n\n// check if the file exists at all\nif (!file_exists($source_file)) {\n  header(\"Status: 404 Not Found\");\n  exit();\n}\n\n/* check that PHP has the GD library available to use for image re-sizing */\nif (!extension_loaded('gd')) { // it's not loaded\n  if (!function_exists('dl') || !dl('gd.so')) { // and we can't load it either\n    // no GD available, so deliver the image straight up\n    trigger_error('You must enable the GD extension to make use of Adaptive Images', E_USER_WARNING);\n    sendImage($source_file, $browser_cache);\n  }\n}\n\n/* Check to see if a valid cookie exists */\nif (isset($_COOKIE['resolution'])) {\n  $cookie_value = $_COOKIE['resolution'];\n\n  // does the cookie look valid? [whole number, comma, potential floating number]\n  if (! preg_match(\"/^[0-9]+[,]*[0-9\\.]+$/\", \"$cookie_value\")) { // no it doesn't look valid\n    setcookie(\"resolution\", \"$cookie_value\", time()-100); // delete the mangled cookie\n  }\n  else { // the cookie is valid, do stuff with it\n    $cookie_data   = explode(\",\", $_COOKIE['resolution']);\n    $client_width  = (int) $cookie_data[0]; // the base resolution (CSS pixels)\n    $total_width   = $client_width;\n    $pixel_density = 1; // set a default, used for non-retina style JS snippet\n    if (@$cookie_data[1]) { // the device's pixel density factor (physical pixels per CSS pixel)\n      $pixel_density = $cookie_data[1];\n    }\n\n    rsort($resolutions); // make sure the supplied break-points are in reverse size order\n    $resolution = $resolutions[0]; // by default use the largest supported break-point\n\n    // if pixel density is not 1, then we need to be smart about adapting and fitting into the defined breakpoints\n    if($pixel_density != 1) {\n      $total_width = $client_width * $pixel_density; // required physical pixel width of the image\n\n      // the required image width is bigger than any existing value in $resolutions\n      if($total_width > $resolutions[0]){\n        // firstly, fit the CSS size into a break point ignoring the multiplier\n        foreach ($resolutions as $break_point) { // filter down\n          if ($total_width <= $break_point) {\n            $resolution = $break_point;\n          }\n        }\n        // now apply the multiplier\n        $resolution = $resolution * $pixel_density;\n      }\n      // the required image fits into the existing breakpoints in $resolutions\n      else {\n        foreach ($resolutions as $break_point) { // filter down\n          if ($total_width <= $break_point) {\n            $resolution = $break_point;\n          }\n        }\n      }\n    }\n    else { // pixel density is 1, just fit it into one of the breakpoints\n      foreach ($resolutions as $break_point) { // filter down\n        if ($total_width <= $break_point) {\n          $resolution = $break_point;\n        }\n      }\n    }\n  }\n}\n\n/* No resolution was found (no cookie or invalid cookie) */\nif (!$resolution) {\n  // We send the lowest resolution for mobile-first approach, and highest otherwise\n  $resolution = $is_mobile ? min($resolutions) : max($resolutions);\n}\n\n/* if the requested URL starts with a slash, remove the slash */\nif(substr($requested_uri, 0,1) == \"/\") {\n  $requested_uri = substr($requested_uri, 1);\n}\n\n/* whew might the cache file be? */\n$cache_file = $document_root.\"/$cache_path/$resolution/\".$requested_uri;\n\n/* Use the resolution value as a path variable and check to see if an image of the same name exists at that path */\nif (file_exists($cache_file)) { // it exists cached at that size\n  if ($watch_cache) { // if cache watching is enabled, compare cache and source modified dates to ensure the cache isn't stale\n    $cache_file = refreshCache($source_file, $cache_file, $resolution);\n  }\n\n  sendImage($cache_file, $browser_cache);\n}\n\n/* It exists as a source file, and it doesn't exist cached - lets make one: */\n$file = generateImage($source_file, $cache_file, $resolution);\nsendImage($file, $browser_cache);"]],"start1":0,"start2":0,"length1":0,"length2":12398}]],"length":12398}
{"contributors":[],"silentsave":true,"ts":1373035505629,"patch":[[{"diffs":[[0," = \""],[-1,"ai-cache"],[0,"\"; /"]],"start1":696,"start2":696,"length1":16,"length2":8}]],"length":12390,"saved":false}
{"ts":1373035509646,"patch":[[{"diffs":[[0,"h    = \""],[1,".."],[0,"\"; // wh"]],"start1":692,"start2":692,"length1":16,"length2":18}]],"length":12392,"saved":false}
{"ts":1373035512001,"patch":[[{"diffs":[[0,"   = \".."],[1,"/"],[0,"\"; // wh"]],"start1":694,"start2":694,"length1":16,"length2":17}]],"length":12393,"saved":false}
{"ts":1373035516283,"patch":[[{"diffs":[[0,"  = \"../"],[1,"adaptative"],[0,"\"; // wh"]],"start1":695,"start2":695,"length1":16,"length2":26}]],"length":12403,"saved":false}
{"ts":1373035517039,"patch":[[{"diffs":[[0,"aptative"],[1,"-"],[0,"\"; // wh"]],"start1":705,"start2":705,"length1":16,"length2":17}]],"length":12404,"saved":false}
{"ts":1373035517492,"patch":[[{"diffs":[[0,"ptative-"],[1,"ima"],[0,"\"; // wh"]],"start1":706,"start2":706,"length1":16,"length2":19}]],"length":12407,"saved":false}
{"ts":1373035518745,"patch":[[{"diffs":[[0,"tive-ima"],[1,"ges"],[0,"\"; // wh"]],"start1":709,"start2":709,"length1":16,"length2":19}]],"length":12410,"saved":false}
{"ts":1373035522018,"patch":[[{"diffs":[[0,"e-images"],[1,"/cache"],[0,"\"; // wh"]],"start1":712,"start2":712,"length1":16,"length2":22}]],"length":12416,"saved":false}
{"ts":1373035523300,"patch":[[{"diffs":[[0,"es/cache"],[1,"/"],[0,"\"; // wh"]],"start1":718,"start2":718,"length1":16,"length2":17}]],"length":12417,"saved":false}
{"ts":1373035526019,"patch":[[{"diffs":[[0,"es/cache"],[-1,"/"],[0,"\"; // wh"]],"start1":718,"start2":718,"length1":17,"length2":16}]],"length":12416,"saved":false}
